package model;

import org.json.JSONArray;
import org.json.JSONObject;
import persistence.Writable;

import java.util.ArrayList;
import java.util.List;

// Represents the player, Keeps track of population, economy, and buildings.
public class Player implements Writable {
    static final int TICK_SPEED = 50;     // Tracks the speed of the tick speed in milliseconds

    private int populationCount = 0;      // Tracks the population count
    private int treasury = 0;             // Tracks the state treasury
    private int income = 0;               // Tracks the total income per tick
    private int populationTick = 0;       // Tracks how much population increased per tick
    private int taxPerPerson = 1;         // Tracks how much tax each person generate
    //private List<UniqueBuilding> uniqueBuildingList = new ArrayList<>(); // Tracks all the unique buildings
    private List<PopulationBuilding> popBuildingList = new ArrayList<>(); // Tracks all the population buildings
    private EventLog eventLog;            // A log of events tracking the purchase and sale of buildings

    // EFFECTS: Creates new instance of Player

    public Player() {
    }

    public Player(int populationCount, int treasury, int income, int populationTick) {
//        this.tickSpeed = tickSpeed;
        this.populationCount = populationCount;
        this.treasury = treasury;
        this.income = income;
        this.populationTick = populationTick;
//        this.taxPerPerson = taxPerPerson;
        eventLog = EventLog.getInstance();
    }

    public int getTickSpeed() {
        return TICK_SPEED;
    }

    /*
     * MODIFIES: this
     * EFFECTS: Processes each tick, first calculates population growth and apply growth
     *          then calculates income and add to treasury.
     */
    public void tick() {
        calculatePopulationTick();
        populationCount += populationTick;
        calculateIncome();
        treasury += income;
    }

    /*
     * MODIFIES: this
     * EFFECTS: calculate income based on the tax generated by the population
     *          and income generated by unique buildings(WIP).
     */
    public void calculateIncome() {
        income = populationCount * taxPerPerson;
//        for (UniqueBuilding uniqueBuilding : uniqueBuildingList) {
//            income += uniqueBuilding.getIncomePerTik();
//        }
    }

    /*
     * MODIFIES: this
     * EFFECTS: calculate population growth based on adding
     *          population growth provided by all owned population buildings
     */
    public void calculatePopulationTick() {
        int totalBuildingPop = 0;
        for (PopulationBuilding b : popBuildingList) {
            totalBuildingPop += b.getPopPerTick();
        }
        populationTick = totalBuildingPop;
    }

    public int getPopulationCount() {
        return populationCount;
    }

    public void addPop() {
        populationCount++;
    }

    public int getTreasury() {
        return treasury;
    }

    public int getIncome() {
        return income;
    }

    public int getPopulationTick() {
        return populationTick;
    }

    /*
     * MODIFIES: this
     * EFFECTS: purchases building if player has sufficient funding,
     *          returns a string for future GUI implementation.
     */
    public String buyBuilding(PopulationBuilding b) {
        if (treasury >= b.getPrice()) {
            popBuildingList.add(b);
            treasury -= b.getPrice();
            eventLog.logEvent(new Event("Bought " + b.getName() + " for " + b.getPrice() + " gold"));
            return "You bought a " + b.getName();
        } else {
            return "Not enough money, you have " + treasury + "You need " + b.getPrice() + " for a " + b.getName();
        }
    }

    /*
     * MODIFIES: this
     * EFFECTS: If the players owns a building of that type, sells if for the building value,
     *          returns a string for future GUI implementation.
     */
    public String sellBuilding(PopulationBuilding b) {
        if (popBuildingList.contains(b)) {
            treasury += b.getValue();
            popBuildingList.remove(b);
            eventLog.logEvent(new Event("Sold " + b.getName() + " for " + b.getValue() + " gold"));
            return "Sold " + b.getName() + " for " + b.getValue() + " gold";
        }
        return "Nothing to sell";
    }

    /*
     * MODIFIES: this
     * EFFECTS: Returns a list of buildings of the parameter type,
     *          returns an empty list if there is not matching buildings
     */
    public List<PopulationBuilding> getBuildingsListByType(PopulationBuilding b) {
        List<PopulationBuilding> blist = new ArrayList<>();
        for (PopulationBuilding building : popBuildingList) {
            if (building.equals(b)) {
                blist.add(building);
            }
        }
        return blist;
    }

    public List<PopulationBuilding> getPopBuildingList() {
        return popBuildingList;
    }


    @Override
    public JSONObject toJson() {
        JSONObject json = new JSONObject();
        json.put("popCount", populationCount);
        json.put("popTick", populationTick);
        json.put("treasury", treasury);
        json.put("income", income);
        json.put("popBuilding", buildingsToJson());

        return json;
    }

    private JSONArray buildingsToJson() {
        JSONArray jsonArray = new JSONArray();

        for (PopulationBuilding b : popBuildingList) {
            jsonArray.put(b.toJson());
        }

        return jsonArray;
    }

    public void addPopBuilding(PopulationBuilding b) {
        popBuildingList.add(b);
    }


}
